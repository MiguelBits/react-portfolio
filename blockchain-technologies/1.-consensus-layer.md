---
description: >-
  Definition: A generally accepted opinion or decision among a group of people:
  "there is a growing consensus that the current regime has failed"
---

# 1. Consensus Layer

### Properties:

A **public** append-only data structure that provides:

* **Persistence:** once added, data can never be removed; \*
* **Safety:** all honest participants have the same data; \*
* **Liveness:** honest participants can add new transactions;
* **Open:** anyone can add data (no authentication);

\*(achieved by replication)

## How does it work in practice?

The consensus mechanism allows users in the blockchain to do transactions without relying on a central authority to verify the said transaction.

Each user in the blockchain has a private key to sign their transactions. So after the creation of a transaction, the user must sign its transaction before sending it to the blockchain network, which is basically a collection of miners.

The transaction is then received by the blockchain network validators, these are called miners, then they propagate the information of the transaction, replicating it throughout the P2P network.

After this there's a leader election mechanism, where one of the miners gets elected, this leader will be creating the next block in the chain.

The leader takes all pending transactions, also called all the transactions in the _mempool_, creates a block out of them. And then he posts this new block onto the blockchain. Since he did this work to create the block he will be rewarded.

All the other miners then validate this new block, if it is invalid the block is treated as if it was never posted to the blockchain.

This process is then repeated all over again, and this is how a blockchain evolves.

## Miners & Byzantine Fault Tolerance Algorithm

_Reference:_ [_https://twitter.com/threesigma\_xyz_](https://twitter.com/threesigma\_xyz)__

Byzantine Fault Tolerance is a computer system's ability to continue operating even if some of its nodes fail or act maliciously. The term comes from a hypothetical called the Byzantine Generals Problem. This logical dilemma, as you'd expect, is about a group of Byzantine generals. So lets get to understand what the problem is.

Welcome to the Byzantine Army, kid, strap your boots on, shine your helmet, and pick up your impossibly heavy shield – we’re going conquerin’. You’ve come at just the right time – we’ve got this city surrounded but have an unfortunately complicated logistics issue here. We have two armies, one on each side of the enemy city, and we need to attack at the same exact time. The city is strong enough to defend itself against one of our armies, but not strong enough to defend against two at the same time. If we don’t attack at the same time, we lose. And losing sucks.

So, the generals of each army need to agree on the exact moment of when to attack. They communicate by sending a messenger back and forth through the enemy city. There’s no other way to communicate – cell phone service wasn’t the best around 600 AD. For example, General A will send the message “Hey General B, we’re going to attack on Thursday. Can we count on you to attack with us?” The messenger then runs through the city and delivers the message to General B, who in turn responds, “We can’t do Thursday, group pilates. How about Friday? If we attack on Friday, will you attack with us?” And then the messenger runs through the city to deliver the message to General A, and so forth. However, here’s the kicker: the messenger could potentially get caught in the city and replaced by a #fakenews messenger, who will intentionally try to deceive the other general to attack the city at the wrong time, dooming our army to a loss.

There is no way to check if the message is authentic, so how do we, as the finest military strategists in the land, create a “trustless” system that ensures victory in attacking the city? And that’s the Byzantine Generals Problem. Byzantine Fault Tolerance Explained

## Consensus Algorithms&#x20;

**Proof of work (PoW)** is a decentralized consensus mechanism that requires members of a network to expend effort solving an arbitrary mathematical puzzle to prevent anybody from gaming the system. Bitcoin is a digital currency that is underpinned by a kind of distributed ledger known as a blockchain. This ledger contains a record of all bitcoin transactions, arranged in sequential "blocks," so that no user is allowed to spend any of their holdings twice. In order to prevent tampering, the ledger is public, or "distributed"; an altered version would quickly be rejected by other users. The way that users detect tampering in practice is through hashes , long strings of numbers that serve as proof of work. Put a given set of data through a hash function (bitcoin uses SHA-256), and it will only ever generate one hash. Due to the "avalanche effect," however, even a tiny change to any portion of the original data will result in a totally unrecognisable hash. Whatever the size of the original data set, the hash generated by a given function will be the same length. The hash is a one-way function: it cannot be used to obtain the original data, only to check that the data that generated the hash matches the original data.

**Proof of stake (PoS)** is the consensus mechanism that helps choose which participants get to handle this lucrative task—lucrative because the chosen ones are rewarded with new crypto if they accurately validate the new data and don’t cheat the system. With proof of stake, participants referred to as “validators” lock up set amounts of cryptocurrency or crypto tokens —their stake, as it were—in a smart contract on the blockchain. In exchange, they get a chance to validate new transactions and earn a reward. But if they improperly validate bad or fraudulent data, they may lose some or all of their stake as a penalty.





