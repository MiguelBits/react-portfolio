---
description: Solidity programming practices
---

# Best Practices

### SafeMath

> “Arithmetic operations in Solidity wrap on overflow. This can easily result in bugs, because programmers usually assume that an overflow raises an error, which is the standard behavior in high level programming languages. \`SafeMath\` restores this intuition by reverting the transaction when an operation overflows.
>
> Using this library instead of the unchecked operations eliminates an entire class of bugs, so it’s recommended to use it always.” — [OpenZeppelin docs](https://docs.openzeppelin.com/contracts/3.x/api/math)

“Operations in Solidity wrap on overflow” refers to a specific thing bound to the way numbers are represented in computers and in Solidity, in particular.

_Overflow_ and _Underflow_ example:

![](<../../.gitbook/assets/imagem (4) (1).png>)What you see in the figure is what the sentence “operations in Solidity wrap on overflow” means. Now, just imagine if the `uint8` we fiddled with represents an amount of some precious assets. This just means that your system will work gloriously in the majority of cases (increments and decrements far from the limits of the representation) and will fail dramatically, producing an inconsistent state.

![](<../../.gitbook/assets/imagem (2) (1) (1).png>)![](<../../.gitbook/assets/imagem (5) (1) (1).png>)

At this point, it is clear that _we do need a safer math —_ even in the simplest smart contract.

**SafeMath** is provided by _OpenZeppelin_ for `uint256`. This means that it will never overflow with our example that uses `uint8`. For example, you should overflow if you pass a 255, but it will not because it will be represented within SafeMath as a `uint256`.

_Reference:_ [https://betterprogramming.pub/solidity-do-we-really-need-a-safer-math-733ea7a9ea44](https://betterprogramming.pub/solidity-do-we-really-need-a-safer-math-733ea7a9ea44)

### Call functions from another deployed contract

Reference: [https://ethereum.stackexchange.com/questions/9733/calling-function-from-deployed-contract](https://ethereum.stackexchange.com/questions/9733/calling-function-from-deployed-contract)

you'll have 3 files.

**AbstractA**.sol contains:

```csharp
contract A {
   function f1(bool arg1, uint arg2) returns(uint); // No implementation, just the function signature. This is just so Solidity can work out how to call it.
}
```

**YourContract**.sol contains:

```javascript
import "AbstractA.sol"

contract YourContract {
  function doYourThing(address addressOfA) returns(uint) {
    A my_a = A(addressOfA);
    return my_a.f1(true, 3);
  }
}
```

**A**.sol contains:

```csharp
contract A {
   // implementation of f1
   function f1(bool arg1, uint arg2) returns(uint) {
       if (arg1) {
           throw;
       } else {
           return arg2;
       }
   }
}
```

Once you make a transaction we have a **Javascript** tutorial to [wait and get details about the transactions](https://ethereumdev.io/waiting-for-a-transaction-to-be-mined-on-ethereum-with-js/) that were made to your contract and a [tutorial to decode events generated by token transfers or any other events](https://ethereumdev.io/how-to-decode-event-logs-in-javascript-using-abi-decoder/) as long as you have the **ABI**

## **Be aware of the tradeoffs between abstract contracts and interfaces**

Both interfaces and abstract contracts provide one with a customizable and re-usable approach for smart contracts. Interfaces, which were introduced in Solidity 0.4.11, are similar to abstract contracts but cannot have any functions implemented. Interfaces also have limitations such as not being able to access storage or inherit from other interfaces which generally makes abstract contracts more practical. Although, interfaces are certainly useful for designing contracts prior to implementation. Additionally, it is important to keep in mind that if a contract inherits from an abstract contract it must implement all non-implemented functions via overriding or it will be abstract as well.

## **Use interface type instead of the address for type safety**

When a function takes a contract address as an argument, it is better to pass an interface or contract type rather than raw `address`. If the function is called elsewhere within the source code, the compiler it will provide additional type safety guarantees.

Here we see two alternatives:

```solidity
contract Validator {
    function validate(uint) external returns(bool);
}

contract TypeSafeAuction {
    // good
    function validateBet(Validator _validator, uint _value) internal returns(bool) {
        bool valid = _validator.validate(_value);
        return valid;
    }
}

contract TypeUnsafeAuction {
    // bad
    function validateBet(address _addr, uint _value) internal returns(bool) {
        Validator validator = Validator(_addr);
        bool valid = validator.validate(_value);
        return valid;
    }
}C
```

The benefits of using the `TypeSafeAuction` contract above can then be seen from the following example. If `validateBet()` is called with an `address` argument, or a contract type other than `Validator`, the compiler will throw this error:

```solidity
contract NonValidator{}

contract Auction is TypeSafeAuction {
    NonValidator nonValidator;

    function bet(uint _value) {
        bool valid = validateBet(nonValidator, _value); // TypeError: Invalid type for argument in function call.
                                                        // Invalid implicit conversion from contract NonValidator
                                                        // to contract Validator requested.
    }
}
```

## **Be aware that ‘Built-ins’ can be shadowed**

It is currently possible to [shadow](https://en.wikipedia.org/wiki/Variable\_shadowing) built-in globals in Solidity. This allows contracts to override the functionality of built-ins such as `msg` and `revert()`. Although this [is intended](https://github.com/ethereum/solidity/issues/1249), it can mislead users of a contract as to the contract’s true behavior.

```solidity
contract PretendingToRevert {
    function revert() internal constant {}
}

contract ExampleContract is PretendingToRevert {
    function somethingBad() public {
        revert();
    }
}
```

Contract users (and auditors) should be aware of the full smart contract source code of any application they intend to use.

## **Use events to monitor contract activity**

It can be useful to have a way to monitor the contract’s activity after it was deployed. One way to accomplish this is to look at all transactions of the contract, however that may be insufficient, as message calls between contracts are not recorded in the blockchain. Moreover, it shows only the input parameters, not the actual changes being made to the state. Also events could be used to trigger functions in the user interface.

```solidity
contract Charity {
    mapping(address => uint) balances;

    function donate() payable public {
        balances[msg.sender] += msg.value;
    }
}

contract Game {
    function buyCoins() payable public {
        // 5% goes to charity
        charity.donate.value(msg.value / 20)();
    }
}Code language: JavaScript (javascript)
```

Here, `Game` contract will make an internal call to `Charity.donate()`. This transaction won’t appear in the external transaction list of `Charity`, but only visible in the internal transactions.

An event is a convenient way to log something that happened in the contract. Events that were emitted stay in the blockchain along with the other contract data and they are available for future audit. Here is an improvement to the example above, using events to provide a history of the Charity’s donations.

```solidity
contract Charity {
    // define event
    event LogDonate(uint _amount);

    mapping(address => uint) balances;

    function donate() payable public {
        balances[msg.sender] += msg.value;
        // emit event
        emit LogDonate(msg.value);
    }
}

contract Game {
    function buyCoins() payable public {
        // 5% goes to charity
        charity.donate.value(msg.value / 20)();
    }
}Code language: JavaScript (javascript)
```

Here, all transactions that go through the `Charity` contract, either directly or not, will show up in the event list of that contract along with the amount of donated money.

**Note: Prefer newer Solidity constructs**. Prefer constructs/aliases such as `selfdestruct` (over `suicide`) and `keccak256` (over `sha3`). Patterns like `require(msg.sender.send(1 ether))` can also be simplified to using `transfer()`, as in `msg.sender.transfer(1 ether)`. Check out [Solidity Change log](https://github.com/ethereum/solidity/blob/develop/Changelog.md) for more similar changes.

\
**Lock pragmas to specific compiler version**
---------------------------------------------

Contracts should be deployed with the same compiler version and flags that they have been tested the most with. Locking the pragma helps ensure that contracts do not accidentally get deployed using, for example, the latest compiler which may have higher risks of undiscovered bugs. Contracts may also be deployed by others and the pragma indicates the compiler version intended by the original authors.

```solidity
// bad
pragma solidity ^0.4.4;


// good
pragma solidity 0.4.4;Code language: JavaScript (javascript)
```

Note: a floating pragma version (ie. `^0.4.25`) will compile fine with `0.4.26-nightly.2018.9.25`, however nightly builds should never be used to compile code for production.

**Warning:** Pragma statements can be allowed to float when a contract is intended for consumption by other developers, as in the case with contracts in a library or EthPM package. Otherwise, the developer would need to manually update the pragma in order to compile locally.

See [SWC-103](https://swcregistry.io/docs/SWC-103)

## **Use modifiers only for checks**

The code inside a modifier is usually executed before the function body, so any state changes or external calls will violate the [Checks-Effects-Interactions](https://solidity.readthedocs.io/en/develop/security-considerations.html#use-the-checks-effects-interactions-pattern) pattern. Moreover, these statements may also remain unnoticed by the developer, as the code for modifier may be far from the function declaration. For example, an external call in modifier can lead to the reentrancy attack:

```solidity
contract Registry {
    address owner;

    function isVoter(address _addr) external returns(bool) {
        // Code
    }
}

contract Election {
    Registry registry;

    modifier isEligible(address _addr) {
        require(registry.isVoter(_addr));
        _;
    }

    function vote() isEligible(msg.sender) public {
        // Code
    }
}Code language: JavaScript (javascript)
```

In this case, the `Registry` contract can make a reentracy attack by calling `Election.vote()` inside `isVoter()`.

**Note:** Use [modifiers](https://solidity.readthedocs.io/en/develop/contracts.html#function-modifiers) to replace duplicate condition checks in multiple functions, such as `isOwner()`, otherwise use `require` or `revert` inside the function. This makes your smart contract code more readable and easier to audit.

## **Beware rounding with integer division**

All integer division rounds down to the nearest integer. If you need more precision, consider using a multiplier, or store both the numerator and denominator.

(In the future, Solidity will have a [fixed-point](https://solidity.readthedocs.io/en/develop/types.html#fixed-point-numbers) type, which will make this easier.)

```javascript
// bad
uint x = 5 / 2; // Result is 2, all integer divison rounds DOWN to the nearest integerCode language: JavaScript (javascript)
```

Using a multiplier prevents rounding down, this multiplier needs to be accounted for when working with x in the future:

```javascript
// good
uint multiplier = 10;
uint x = (5 * multiplier) / 2;Code language: JavaScript (javascript)
```

Storing the numerator and denominator means you can calculate the result of `numerator/denominator` off-chain:

```javascript
// good
uint numerator = 5;
uint denominator = 2;Code language: JavaScript (javascript)
```
